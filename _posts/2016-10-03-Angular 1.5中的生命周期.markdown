---
layout: post
title:  "Angular 1.5中的生命周期"
date:   2016-10-03 +0800
categories: angular
---
了解React的小伙伴对生命周期的概念都不会感到陌生，angularjs在1.5版本中也加入了生命周期，以此来过渡到angular2.0。以下简单介绍一下angular1.5中的生命周期。

$onInit

什么是$onInit

$onInit是一个预设在Angular组件控制器中的暴露给开发者的接口，我们可以对其附件一个函数进行操作。
{% highlight javascript %}
var myComponent = {
  bindings: {},
  controller: function () {
    this.$onInit = function() {

    };
  }
};

angular
  .module('app')
  .component('myComponent', myComponent);
{% endhighlight %}
使用$onInit

$onInit的作用是初始化controller中所有对象。
{% highlight javascript %}
var myComponent = {
	...
controller: function () {
    this.foo = 'bar';
    this.bar = 'foo';
    this.fooBar = function () {

    	};
  	}
};
{% endhighlight %}
注意我们是如何在controller中创建属性的，有种随意乱放的感觉。接下来，我们可以使用$onInit让代码变得合理一些。
{% highlight javascript %}
var myComponent = {
  ...
  controller: function () {
this.$onInit = function () {
  this.foo = 'bar';
  this.bar = 'foo';
};
this.fooBar = function () {
      console.log(this.foo); // 'bar'
	    };
  }
};
{% endhighlight %}
以上的数据片段显然是种硬编码，但在实际开发中我们希望从bindings: {}对象中获取数据，继而传入组件中。我们想要让用来初始化的变量、对象等不再随意摆放。

$onInit + “require”
因为生命周期界限划分清晰，我们因此可在$onInit中进行继承操作。
让我们用myComponent继续举例说明一下。
{% highlight javascript %}
var myComponent = {
  ...
  require: {
  parent: '^^anotherComponent'
  },
  controller: function () {
	  this.$onInit = function ()｛
	  this.foo = 'bar';
	  this.bar = 'foo';
  };
  this.fooBar = function () {
	  console.log(this.foo); // 'bar'
	  };
  }
};
{% endhighlight %}
现在require被设置成^^anotherComponent，我们可以在$onInit中继承相关属性了。（^^anotherComponent表示只继承父组件controller中的方法，^anotherComponent 则同级组件中寻找，如果没有再从父组件中继承。）
{% highlight javascript %}
var myComponent = {
  ...
  require: {
    parent: '^^anotherComponent'
  },
  controller: function () {
    this.$onInit = function () {
      this.foo = 'bar';
      this.bar = 'foo';
      this.parent.sayHi();
    };
    this.fooBar = function () {
      console.log(this.foo); // 'bar'
    };
  }
};
{% endhighlight %}
值得注意的是在Angular1.5.6中，如果一个同样用来绑定一个需要require的controller，那么可以省略这个这个controller的名字。这个特性没有太多突破性的改变，我们可以这么使用：
{% highlight javascript %}
var myComponent = {
  ...
  require: {
    parent: '^^'
  },
  controller: function () {
    ...
  }
};
{% endhighlight %}
就像你所看到的，我们仅使用^^就完全代替了controller的名字。

揭秘$onInit与require
先用$onInit和require创建一个tab组件。
{% highlight javascript %}
<tabs>
  <tab label="Tab 1">
    Tab 1 contents!
   </tab>
   <tab label="Tab 2">
    Tab 2 contents!
   </tab>
   <tab label="Tab 3">
    Tab 3 contents!
   </tab>
</tabs>
{% endhighlight %}
由此可见，我们需要两个子组件，tab和tabs。我们需要将所有的tab组件嵌套在tabs组件中，并且要通过绑定获取label值。

首先，声明个组件需要的属性。
{% highlight javascript %}
var tab = {
  bindings: {},
  require: {},
  transclude: true,
  template: ``,
  controller: function () {}
};

var tabs = {
  transclude: true,
  template: ``,
  controller: function () {}
};

angular
  .module('app', [])
  .component('tab', tab)
  .component('tabs', tabs);
{% endhighlight %}
tab组件还需要一些对象绑定，包括require，transclude，template，controller。

tabs组件用transclude到我们的tab组件到自己的template中，然后通过controller进行处理。

让我们先写出tab的template：
{% highlight javascript %}
var tab = {
  ...
  template: `
    <div class="tabs__content" ng-if="$ctrl.tab.selected">
      <div ng-transclude></div>
    </div>
  `,
  ...
};
{% endhighlight %}
对于tab来说，我们需要当属性$ctrl.tab.selected是true时展示详细的tab，所以我们需要一些逻辑来处理这个。
{% highlight javascript %}
var tabs = {
  ...
  template: `
    <div class="tabs">
      <ul class="tabs__list">
        <li ng-repeat="tab in $ctrl.tabs">
          <a href=""
            ng-bind="tab.label"
            ng-click="$ctrl.selectTab($index);"></a>
        </li>
      </ul>
      <div class="tabs__content" ng-transclude></div>
    </div>
  `,
  ...
};
{% endhighlight %}
然后对于tabs，我们将创建一个数组来展示$ctrl.tabs，并绑定一个点击事件$ctrl.selectTab()。

下一步就是编写tab组件的控制器，我们将创造this.tab属性。
{% highlight javascript %}
var tab = {
  bindings: {
    label: '@'
  },
  ...
  template: `
    <div class="tabs__content" ng-if="$ctrl.tab.selected">
      <div ng-transclude></div>
    </div>
  `,
  controller: function () {
    this.$onInit = function () {
      this.tab = {
        label: this.label,
        selected: false
      };
    };
  }
  ...
};
{% endhighlight %}
可以看到我也在controller中使用this.label，并且添加了bindings: { label: '@' }。

再看tabs的controller，稍微有那么一点点复杂：
{% highlight javascript %}
var tabs = {
  ...
  template: `
    <div class="tabs">
      <ul class="tabs__list">
        <li ng-repeat="tab in $ctrl.tabs">
          <a href=""
            ng-bind="tab.label"
            ng-click="$ctrl.selectTab($index);"></a>
        </li>
      </ul>
      <div class="tabs__content" ng-transclude></div>
    </div>
  `,
  controller: function () {
    this.$onInit = function () {
      this.tabs = [];
    };
    this.addTab = function addTab(tab) {
      this.tabs.push(tab);
    };
    this.selectTab = function selectTab(index) {
      for (var i = 0; i < this.tabs.length; i++) {
        this.tabs[i].selected = false;
      }
      this.tabs[index].selected = true;
    };
  },
  ...
};
{% endhighlight %}
我们在$onInit中设置this.tabs = []，然后定义了两个function，addTab和selectTab。
下一步，我们在tab组件上使用require来代理addTab方法。
{% highlight javascript %}
var tab = {
  ...
  require: {
    tabs: '^^'
  },
  ...
};
{% endhighlight %}
接下来使用^^从父级require相应的方法。
{% highlight javascript %}
var tab = {
  ...
  require: {
    tabs: '^^'
  },
  controller: function () {
    this.$onInit = function () {
      this.tab = {
        label: this.label,
        selected: false
      };
      // this.tabs === require: { tabs: '^^' }
      this.tabs.addTab(this.tab);
    };
  }
  ...
};
{% endhighlight %}
糅合到一起之后的样子：
{% highlight javascript %}
var tab = {
  bindings: {
    label: '@'
  },
  require: {
    tabs: '^^'
  },
  transclude: true,
  template: `
    <div class="tabs__content" ng-if="$ctrl.tab.selected">
      <div ng-transclude></div>
    </div>
  `,
  controller: function () {
    this.$onInit = function () {
      this.tab = {
        label: this.label,
        selected: false
      };
      this.tabs.addTab(this.tab);
    };
  }
};

var tabs = {
  transclude: true,
  controller: function () {
    this.$onInit = function () {
      this.tabs = [];
    };
    this.addTab = function addTab(tab) {
      this.tabs.push(tab);
    };
    this.selectTab = function selectTab(index) {
      for (var i = 0; i < this.tabs.length; i++) {
        this.tabs[i].selected = false;
      }
      this.tabs[index].selected = true;
    };
  },
  template: `
    <div class="tabs">
      <ul class="tabs__list">
        <li ng-repeat="tab in $ctrl.tabs">
          <a href=""
            ng-bind="tab.label"
            ng-click="$ctrl.selectTab($index);"></a>
        </li>
      </ul>
  <div class="tabs__content" ng-transclude></div>
    </div>
  `
};
{% endhighlight %}
点击tab相应的contents会显示，但是我们还没设置一个初始的tab，这时我们需要引入$postLink。

$postLink
到目前为止我们都了解了指令，我们有compile方法可以返回pre与post“link”方法。它看起来貌似是这样的：
{% highlight javascript %}
function myDirective() {
  restrict: 'E',
  scope: { foo: '=' },
  compile: function compile($element, $attrs) {
    return {
      pre: function preLink($scope, $element, $attrs) {
        // access to child elements that are NOT linked
      },
      post: function postLink($scope, $element, $attrs) {
        // access to child elements that are linked
      }
    };
  }
}
{% endhighlight %}
如果这样的话，你可能会更熟悉一点：
{% highlight javascript %}
function myDirective() {
  restrict: 'E',
  scope: { foo: '=' },
  link: function postLink($scope, $element, $attrs) {
    // access to child elements that are linked
  }
}
{% endhighlight %}
如果我们只想使用postLink方法的话，以上两个方法是一样的，没区别。

使用$postLink
{% highlight javascript %}
var myComponent = {
  ...
  controller: function () {
    this.$postLink = function () {
      // fire away...
    };
  }
};
{% endhighlight %}
当所有子元素都linked后，我们被hook通知。

揭秘$postLink
我们可使用$postLink设置tab初始化值。
首先我们需要调整一下模版：
{% highlight html %}
<tabs selected="0">
  <tab label="Tab 1">...</tab>
  <tab label="Tab 2">...</tab>
  <tab label="Tab 3">...</tab>
</tabs>
{% endhighlight %}
现在我们用bindings的selected属性值来进行初始化操作。
{% highlight javascript %}
var tabs = {
  bindings: {
    selected: '@'
  },
  ...
  controller: function () {
    this.$onInit = function () {
      this.tabs = [];
    };
    this.addTab = function addTab(tab) {
      this.tabs.push(tab);
    };
    this.selectTab = function selectTab(index) {
      for (var i = 0; i < this.tabs.length; i++) {
        this.tabs[i].selected = false;
      }
      this.tabs[index].selected = true;
    };
    this.$postLink = function () {
      // use `this.selected` passed down from bindings: {}
      // a safer option would be to parseInt(this.selected, 10)
      // to coerce to a Number to lookup the Array index, however
      // this works just fine for the demo :)
      this.selectTab(this.selected || 0);
    };
  },
  ...
};
{% endhighlight %}
$onChanges

这个方法是很重要的，它密切关系到我们如何在Angular1.5中使用组件化以及单项数据流开发。牢记一条黄金法则，当前父级controller发生状态变化时在当前controller中调用$onChanges。

调用条件

在以下条件下会调用$onChanges。第一，在组件初始化时，向下传递初始化对象。第二是当改变发生在与父级组件通过’<‘和’@‘绑定的情况下。

使用$onChanges

使用$onChanges很简单，首先在子组件中声明一下：
{% highlight javascript %}
var childComponent = {
  bindings: { user: '<' },
  controller: function () {
    this.$onChanges = function (changes) {
      // `changes` is a special instance of a constructor Object,
      // it contains a hash of a change Object and
      // also contains a function called `isFirstChange()`
      // it's implemented in the source code using a constructor Object
      // and prototype method to create the function `isFirstChange()`
    };
  }
};

angular
  .module('app')
  .component('childComponent', childComponent);
{% endhighlight %}
bindings对象中user值为’<‘代表单项数据流，接下来还需要一个父组件。
{% highlight javascript %}
var parentComponent = {
  template: `
    <div>
      <child-component></child-component>
    </div>
  `
};

angular
  .module('app')
  .component('parentComponent', parentComponent);
{% endhighlight %}
子组件在父组件中渲染是不是有种很熟悉的感觉。
{% highlight javascript %}
var parentComponent = {
  template: `
    <div>
      <a href="" ng-click="$ctrl.changeUser();">
        Change user (this will call $onChanges in child)
      </a>
      <child-component
      	user="$ctrl.user">
      </child-component>
    </div>
  `,
  controller: function () {
    this.$onInit = function () {
    	this.user = {
      	name: 'Todd Motto',
        location: 'England, UK'
      };
    };
    this.changeUser = function () {
    	this.user = {
      	name: 'Tom Delonge',
        location: 'California, USA'
      };
    };
  }
};
{% endhighlight %}
再次使用$onInit来定义本地数据。接下俩再次回到子组件：
{% highlight javascript %}
var childComponent = {
  bindings: {
    user: '<'
  },
  template: `
    <div>
      <pre>{{ $ctrl.user | json }}</pre>
    </div>
  `,
  controller: function () {
    this.$onChanges = function (changes) {
      this.user = changes;
    };
  }
};
{% endhighlight %}
我们再次使用bindings: { user: '<' }，表示我们是通过单向数据流的方式来接收数据。

$onDestroy

$onDestroy其实长这样：
{% highlight javascript %}
function SomeController($scope) {
  $scope.$on('$destroy', function () {
    // destroy event
  });
}
{% endhighlight %}
使用$onDestroy
{% highlight javascript %}
var childComponent = {
  bindings: {
    user: '<'
  },
  controller: function () {
    this.$onDestroy = function () {
      // component scope is destroyed
    };
  }
};

angular
  .module('app')
  .component('childComponent', childComponent);
{% endhighlight %}  
结语

Angular向组件化&单项数据的思想转化，原因不言而喻。不断学习先进思想是事物发展进步的必然。